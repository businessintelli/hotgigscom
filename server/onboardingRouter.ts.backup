import { z } from "zod";
import { protectedProcedure, router } from "./_core/trpc";
import { TRPCError } from "@trpc/server";
import * as onboardingDb from "./onboardingDb";
import { sendEmail } from "./emailNotifications";

export const onboardingRouter = router({
  // Associate Management
  getAllAssociates: protectedProcedure.query(async () => {
    return await onboardingDb.getAllAssociates();
  }),

  getAssociateById: protectedProcedure
    .input(z.object({ id: z.number() }))
    .query(async ({ input }) => {
      return await onboardingDb.getAssociateById(input.id);
    }),

  createAssociate: protectedProcedure
    .input(
      z.object({
        candidateId: z.number(),
        startDate: z.string(),
        position: z.string(),
        department: z.string().optional(),
        employeeId: z.string().optional(),
        status: z.string().default("active"),
      })
    )
    .mutation(async ({ input }) => {
      return await onboardingDb.createAssociate(input);
    }),

  updateAssociate: protectedProcedure
    .input(
      z.object({
        id: z.number(),
        status: z.string().optional(),
        endDate: z.string().optional(),
        department: z.string().optional(),
        position: z.string().optional(),
      })
    )
    .mutation(async ({ input }) => {
      const { id, ...updates } = input;
      return await onboardingDb.updateAssociate(id, updates);
    }),

  // Onboarding Process Management
  getAllOnboardingProcesses: protectedProcedure.query(async () => {
    return await onboardingDb.getAllOnboardingProcesses();
  }),

  getOnboardingProcessById: protectedProcedure
    .input(z.object({ id: z.number() }))
    .query(async ({ input }) => {
      return await onboardingDb.getOnboardingProcessById(input.id);
    }),

  initiateOnboarding: protectedProcedure
    .input(
      z.object({
        associateId: z.number(),
        type: z.string(),
        startDate: z.string(),
        targetCompletionDate: z.string(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const process = await onboardingDb.createOnboardingProcess({
        ...input,
        initiatedBy: ctx.user.id,
        status: "in_progress",
      });

      // Send notification email to the associate
      const associate = await onboardingDb.getAssociateById(input.associateId);
      if (associate) {
        await sendEmail({
          to: associate.email || "",
          subject: `${input.type === "onboarding" ? "Welcome" : "Offboarding"} Process Started`,
          html: `
            <h2>${input.type === "onboarding" ? "Welcome to the team!" : "Offboarding Process Initiated"}</h2>
            <p>Your ${input.type} process has been initiated.</p>
            <p><strong>Start Date:</strong> ${input.startDate}</p>
            <p><strong>Target Completion:</strong> ${input.targetCompletionDate}</p>
            <p>You will receive updates as tasks are completed.</p>
          `,
        });
      }

      return process;
    }),

  updateOnboardingProcess: protectedProcedure
    .input(
      z.object({
        id: z.number(),
        status: z.string().optional(),
        actualCompletionDate: z.string().optional(),
      })
    )
    .mutation(async ({ input }) => {
      const { id, ...updates } = input;
      return await onboardingDb.updateOnboardingProcess(id, updates);
    }),

  // Task Management
  getTasksByProcess: protectedProcedure
    .input(z.object({ processId: z.number() }))
    .query(async ({ input }) => {
      return await onboardingDb.getTasksByProcessId(input.processId);
    }),

  createTask: protectedProcedure
    .input(
      z.object({
        processId: z.number(),
        title: z.string(),
        description: z.string().optional(),
        dueDate: z.string(),
        priority: z.string().default("medium"),
        category: z.string().optional(),
      })
    )
    .mutation(async ({ input }) => {
      return await onboardingDb.createTask({
        ...input,
        status: "pending",
      });
    }),

  updateTask: protectedProcedure
    .input(
      z.object({
        id: z.number(),
        status: z.string().optional(),
        completedAt: z.string().optional(),
        notes: z.string().optional(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const { id, ...updates } = input;
      
      // If task is being marked as completed, update completedBy
      if (updates.status === "completed") {
        updates.completedAt = new Date().toISOString();
      }

      const task = await onboardingDb.updateTask(id, updates);

      // Send notification to assigned recruiters
      const assignments = await onboardingDb.getAssignmentsByTaskId(id);
      for (const assignment of assignments) {
        if (assignment.assignedTo) {
          await sendEmail({
            to: assignment.assignedTo.email,
            subject: `Task Updated: ${task.title}`,
            html: `
              <h2>Task Status Update</h2>
              <p><strong>Task:</strong> ${task.title}</p>
              <p><strong>New Status:</strong> ${updates.status}</p>
              ${updates.notes ? `<p><strong>Notes:</strong> ${updates.notes}</p>` : ""}
            `,
          });
        }
      }

      return task;
    }),

  completeTask: protectedProcedure
    .input(
      z.object({
        id: z.number(),
        notes: z.string().optional(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      return await onboardingDb.updateTask(input.id, {
        status: "completed",
        completedAt: new Date().toISOString(),
        notes: input.notes,
      });
    }),

  // Task Assignment Management
  getAssignmentsByTask: protectedProcedure
    .input(z.object({ taskId: z.number() }))
    .query(async ({ input }) => {
      return await onboardingDb.getAssignmentsByTaskId(input.taskId);
    }),

  getAssignmentsByRecruiter: protectedProcedure
    .input(z.object({ recruiterId: z.number() }))
    .query(async ({ input }) => {
      return await onboardingDb.getAssignmentsByRecruiterId(input.recruiterId);
    }),

  assignTask: protectedProcedure
    .input(
      z.object({
        taskId: z.number(),
        assignedTo: z.number(),
        notes: z.string().optional(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const assignment = await onboardingDb.createTaskAssignment({
        ...input,
        assignedBy: ctx.user.id,
        status: "assigned",
      });

      // Send notification email to assigned recruiter
      const task = await onboardingDb.getTaskById(input.taskId);
      const recruiter = await onboardingDb.getRecruiterById(input.assignedTo);
      
      if (task && recruiter) {
        await sendEmail({
          to: recruiter.email,
          subject: `New Task Assigned: ${task.title}`,
          html: `
            <h2>You have been assigned a new task</h2>
            <p><strong>Task:</strong> ${task.title}</p>
            <p><strong>Description:</strong> ${task.description || "No description"}</p>
            <p><strong>Due Date:</strong> ${task.dueDate}</p>
            <p><strong>Priority:</strong> ${task.priority}</p>
            ${input.notes ? `<p><strong>Notes:</strong> ${input.notes}</p>` : ""}
            <p>Please log in to the platform to view and complete this task.</p>
          `,
        });
      }

      return assignment;
    }),

  updateAssignment: protectedProcedure
    .input(
      z.object({
        id: z.number(),
        status: z.string().optional(),
        completedAt: z.string().optional(),
      })
    )
    .mutation(async ({ input }) => {
      const { id, ...updates } = input;
      return await onboardingDb.updateTaskAssignment(id, updates);
    }),

  // Task Templates
  getAllTaskTemplates: protectedProcedure.query(async () => {
    return await onboardingDb.getAllTaskTemplates();
  }),

  createTaskTemplate: protectedProcedure
    .input(
      z.object({
        name: z.string(),
        description: z.string().optional(),
        type: z.string(),
        tasks: z.array(
          z.object({
            title: z.string(),
            description: z.string().optional(),
            daysFromStart: z.number(),
            priority: z.string().default("medium"),
            category: z.string().optional(),
          })
        ),
      })
    )
    .mutation(async ({ input, ctx }) => {
      return await onboardingDb.createTaskTemplate({
        ...input,
        createdBy: ctx.user.id,
      });
    }),

  // Create tasks from template
  // TODO: Fix type issues and re-enable
  /* createTasksFromTemplate: protectedProcedure
    .input(
      z.object({
        processId: z.number(),
        templateId: z.number(),
      })
    )
    .mutation(async ({ input }) => { = await onboardingDb.getTaskTemplateById(input.templateId);
      if (!template) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Task template not found",
        });
      }

      const process = await onboardingDb.getOnboardingProcessById(input.processId);
      if (!process) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Onboarding process not found",
        });
      }

      // Create tasks from template
      const startDate = new Date(process.startDate);
      const tasks = [];

      for (const taskTemplate of template.tasks) {
        const dueDate = new Date(startDate);
        dueDate.setDate(dueDate.getDate() + taskTemplate.daysFromStart);

        const task = await onboardingDb.createTask({
          processId: input.processId,
          title: taskTemplate.title,
          description: taskTemplate.description,
          dueDate: new Date(dueDate),
          priority: taskTemplate.taskTemplates?.priority || "medium",
          category: taskTemplate.taskTemplates?.category || null,
          status: "pending",
        });

        tasks.push(task);
      }

      return tasks;
    }), */

  // Dashboard Stats
  // TODO: Fix type issues and re-enable
  /* getOnboardingStats: protectedProcedure.query(async () => {
    const associates = await onboardingDb.getAllAssociates();
    const processes = await onboardingDb.getAllOnboardingProcesses();
    
    const activeAssociates = associates.filter((a) => a.associates?.status === "active").length;
    const onboardingProcesses = processes.filter(
      (p) => p.onboardingProcesses?.processType === "onboarding" && p.onboardingProcesses?.status === "in_progress"
    ).length;
    const offboardingProcesses = processes.filter(
      (p) => p.onboardingProcesses?.processType === "offboarding" && p.onboardingProcesses?.status === "in_progress"
    ).length;

    return {
      activeAssociates,
      onboardingProcesses,
      offboardingProcesses,
      totalProcesses: processes.length,
    };
  }), */

  // TODO: Fix type issues and re-enable
  /* getPendingTasks: protectedProcedure.query(async ({ ctx }) => {
    // Get all tasks assigned to the current user that are not completed
    const assignments = await onboardingDb.getAssignmentsByRecruiterId(ctx.user.id);
    const pendingTasks = assignments.filter(
      (a) => a.taskAssignments?.status !== "completed" && a.onboardingTasks?.status !== "completed"
    );
    
    return pendingTasks;
  }), */
});
