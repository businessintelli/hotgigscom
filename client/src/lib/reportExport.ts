import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import * as XLSX from 'xlsx';

export interface ExportData {
  title: string;
  headers: string[];
  rows: (string | number)[][];
  metadata?: {
    dateRange?: string;
    generatedAt?: string;
    generatedBy?: string;
  };
}

export function exportToPDF(data: ExportData) {
  const doc = new jsPDF();
  
  // Add title
  doc.setFontSize(18);
  doc.text(data.title, 14, 22);
  
  // Add metadata
  let yPosition = 32;
  if (data.metadata) {
    doc.setFontSize(10);
    if (data.metadata.dateRange) {
      doc.text(`Date Range: ${data.metadata.dateRange}`, 14, yPosition);
      yPosition += 6;
    }
    if (data.metadata.generatedAt) {
      doc.text(`Generated: ${data.metadata.generatedAt}`, 14, yPosition);
      yPosition += 6;
    }
    if (data.metadata.generatedBy) {
      doc.text(`Generated By: ${data.metadata.generatedBy}`, 14, yPosition);
      yPosition += 6;
    }
  }
  
  // Add table
  autoTable(doc, {
    head: [data.headers],
    body: data.rows,
    startY: yPosition + 4,
    theme: 'grid',
    headStyles: {
      fillColor: [147, 51, 234], // Purple color
      textColor: 255,
      fontSize: 10,
      fontStyle: 'bold'
    },
    styles: {
      fontSize: 9,
      cellPadding: 3
    },
    alternateRowStyles: {
      fillColor: [245, 245, 245]
    }
  });
  
  // Save the PDF
  const filename = `${data.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`;
  doc.save(filename);
}

export function exportToExcel(data: ExportData) {
  // Create workbook and worksheet
  const wb = XLSX.utils.book_new();
  
  // Prepare data with headers
  const wsData = [data.headers, ...data.rows];
  
  // Add metadata rows at the top if provided
  if (data.metadata) {
    const metadataRows: (string | number)[][] = [];
    metadataRows.push([data.title]);
    metadataRows.push([]); // Empty row
    
    if (data.metadata.dateRange) {
      metadataRows.push(['Date Range:', data.metadata.dateRange]);
    }
    if (data.metadata.generatedAt) {
      metadataRows.push(['Generated:', data.metadata.generatedAt]);
    }
    if (data.metadata.generatedBy) {
      metadataRows.push(['Generated By:', data.metadata.generatedBy]);
    }
    
    metadataRows.push([]); // Empty row before table
    wsData.unshift(...metadataRows);
  }
  
  // Create worksheet
  const ws = XLSX.utils.aoa_to_sheet(wsData);
  
  // Set column widths
  const colWidths = data.headers.map(() => ({ wch: 20 }));
  ws['!cols'] = colWidths;
  
  // Add worksheet to workbook
  XLSX.utils.book_append_sheet(wb, ws, 'Report');
  
  // Save the file
  const filename = `${data.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.xlsx`;
  XLSX.writeFile(wb, filename);
}

// Helper function to format data for export
export function formatReportData(
  title: string,
  data: any[],
  columns: { key: string; label: string; format?: (value: any) => string }[],
  metadata?: ExportData['metadata']
): ExportData {
  const headers = columns.map(col => col.label);
  const rows = data.map(item =>
    columns.map(col => {
      const value = item[col.key];
      if (col.format) {
        return col.format(value);
      }
      return value !== null && value !== undefined ? String(value) : '';
    })
  );
  
  return {
    title,
    headers,
    rows,
    metadata
  };
}
